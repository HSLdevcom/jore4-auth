package fi.hsl.jore4.auth.apipublic.v1

import com.nimbusds.oauth2.sdk.AuthorizationCode
import com.nimbusds.oauth2.sdk.id.State
import fi.hsl.jore4.auth.oidc.OIDCTokenExchangeService
import io.swagger.annotations.ApiOperation
import io.swagger.annotations.ApiParam
import io.swagger.annotations.ApiResponse
import io.swagger.annotations.ApiResponses
import org.springframework.beans.factory.annotation.Value
import org.springframework.http.HttpStatus
import org.springframework.http.ResponseEntity
import org.springframework.web.bind.annotation.*
import org.springframework.web.util.UriComponentsBuilder
import java.net.URI
import java.net.URLEncoder
import javax.servlet.http.HttpSession

/**
 * OIDC token exchange endpoint controller.
 *
 * Provides the endpoint for exchanging an OIDC authorization code for tokens.
 */
@RestController
class OIDCTokenExchangeApiController(
    private val tokenExchangeService: OIDCTokenExchangeService,
    @Value("\${self.base.url}") private val selfBaseUrl: String,
    @Value("\${api.path.prefix.public}") private val publicApiPrefix: String
) {
    companion object {
        const val EXCHANGE_ENDPOINT_PATH_SUFFIX = "/v1.0/oidc/exchange"
        const val CLIENT_REDIRECT_URL_QUERY_PARAM = "clientRedirectUrl"
    }

    @ApiOperation(
            "This endpoint is invoked by the OIDC authorization server and will exchange the given authorization code for an " +
                    "access and a refresh token. After a successful code exchange, this endpoint will eventually redirect to the " +
                    "configured login page."
    )
    @ApiResponses(
            ApiResponse(code = 302, message = "Redirects to the configured login page."),
            ApiResponse(code = 401, message = "The authenticity of the request cannot be verified.")
    )
    @ResponseStatus(HttpStatus.FOUND)
    @RequestMapping(method = [RequestMethod.GET], value = ["\${api.path.prefix}$EXCHANGE_ENDPOINT_PATH_SUFFIX"])
    fun exchangeTokens(
            @ApiParam("The authorization code passed on by the authorization server.")
            @RequestParam
            code: String,
            @ApiParam("The state to verify the requests authenticity (the state has been generated by us before invoking the auth server's login endpoint).")
            @RequestParam
            state: String,
            @RequestParam(value = CLIENT_REDIRECT_URL_QUERY_PARAM, required = false) clientRedirectUrl: String?,
            session: HttpSession
    ): ResponseEntity<Any> {
        return tokenExchangeService.exchangeTokens(
            AuthorizationCode(code), State(state), session,
            createCallbackUri(clientRedirectUrl), clientRedirectUrl
        )
    }

    /**
     * Create a callback URI pointing to our base URL with the {@param clientRedirectUrl}
     * added as a query parameter.
     *
     * This URI will allow us to return the user to any place, since the client base URL matches the OIDC client
     * URL and will redirect the user to the real destination.
     */
    fun createCallbackUri(clientRedirectUrl: String?): URI {
        var builder = UriComponentsBuilder
            .fromUriString(selfBaseUrl)
            .path("$publicApiPrefix$EXCHANGE_ENDPOINT_PATH_SUFFIX")

        if (clientRedirectUrl != null) {
            builder = builder.queryParam(CLIENT_REDIRECT_URL_QUERY_PARAM, URLEncoder.encode(clientRedirectUrl, "UTF-8"))
        }

        return builder.build()
            .encode()
            .toUri()
    }
}
